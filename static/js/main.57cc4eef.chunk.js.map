{"version":3,"sources":["components/LinkedList.js","lib/utils.js","components/Board.js","App.js","reportWebVitals.js","index.js"],"names":["LinkedListNode","value","this","next","SinglyLinkedList","node","head","tail","randomIntFromInterval","min","max","Math","floor","random","DIRECTION","UP","RIGHT","DOWN","LEFT","createBoard","BOARD_SIZE","counter","board","row","currentRow","col","push","getStartingSnakeLLValue","rowSize","length","colSize","startingRow","startingCol","cell","getRandomDirection","Object","keys","getFoodCell","snakeCells","currentFoodCell","nextFoodCell","has","getCoordsInDirection","coords","direction","isOutOfBounds","getDirectionFromKey","key","getNextNodeDirection","currentDirection","currentCol","nextRow","nextCol","getGrowthNodeCoords","snakeTail","tailNextNodeDirection","growthDirection","getOppositeDirection","currentTailCoords","getCellClassName","cellValue","foodCell","foodShouldReverseDirection","className","Board","useState","score","setScore","snake","setSnake","Set","setSnakeCells","setFoodCell","setDirection","setFoodShouldReverseDirection","useEffect","window","addEventListener","e","handleKeydown","removeEventListener","snakeSpeed","setTimeout","moveSnake","clearTimeout","newDirection","size","currentHeadCoords","nextHeadCoords","handleGameOver","nextHeadCell","newHead","currentHead","newSnakeCells","delete","add","growSnake","reverseSnake","handleFoodConsumption","growthNodeCoords","newTailCell","newTail","currentTail","previousNode","currentNode","nextNode","reverseLinkedList","snakeHead","nextFoodShouldReverseDirection","snakeLLStartingValue","map","rowIndex","cellIndex","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"8NAAaA,EACX,WAAYC,GAAQ,oBAClBC,KAAKD,MAAQA,EACbC,KAAKC,KAAO,MAIHC,EACX,WAAYH,GAAQ,oBAClB,IAAMI,EAAO,IAAIL,EAAeC,GAChCC,KAAKI,KAAOD,EACZH,KAAKK,KAAOF,GCVT,SAASG,EAAsBC,EAAKC,GAEzC,OAAOC,KAAKC,MAAMD,KAAKE,UAAYH,EAAMD,EAAM,GAAKA,G,iBCIhDK,EAAY,CAChBC,GAAI,KACJC,MAAO,QACPC,KAAM,OACNC,KAAM,QA8KFC,EAAc,SAACC,GAGnB,IAFA,IAAIC,EAAU,EACRC,EAAQ,GACLC,EAAM,EAAGA,EAAMH,EAAYG,IAAO,CAEzC,IADA,IAAMC,EAAa,GACVC,EAAM,EAAGA,EAAML,EAAYK,IAClCD,EAAWE,KAAKL,KAElBC,EAAMI,KAAKF,GAEb,OAAOF,GAGHK,EAA0B,SAACL,GAC/B,IAAMM,EAAUN,EAAMO,OAChBC,EAAUR,EAAM,GAAGO,OACnBE,EAAcvB,EAAsB,EAAGoB,EAAU,GACjDI,EAAcxB,EAAsB,EAAGsB,GAE7C,MAAO,CACLP,IAAKQ,EACLN,IAAKO,EACLC,KAJmBX,EAAMS,GAAaC,KAQpCE,EAAqB,WACzB,OAAOC,OAAOC,KAAKtB,GAAWN,EAAsB,EAAG,KASnD6B,EAAc,SAACC,EAAYC,GAG/B,OAAa,CACX,IAAIC,EAAehC,EAAsB,EAHdY,KAI3B,IAAIkB,EAAWG,IAAID,IAAiBD,IAAoBC,EAExD,OAAOA,IAILE,EAAuB,SAACC,EAAQC,GACpC,OAAQA,GACN,KAAK9B,EAAUC,GACb,MAAO,CACLQ,IAAKoB,EAAOpB,IAAM,EAClBE,IAAKkB,EAAOlB,KAEhB,KAAKX,EAAUE,MACb,MAAO,CACLO,IAAKoB,EAAOpB,IACZE,IAAKkB,EAAOlB,IAAM,GAEtB,KAAKX,EAAUG,KACb,MAAO,CACLM,IAAKoB,EAAOpB,IAAM,EAClBE,IAAKkB,EAAOlB,KAEhB,KAAKX,EAAUI,KACb,MAAO,CACLK,IAAKoB,EAAOpB,IACZE,IAAKkB,EAAOlB,IAAM,GAEtB,QACE,MAAO,CACLF,IAAKoB,EAAOpB,IACZE,IAAKkB,EAAOlB,OAKdoB,EAAgB,SAACF,EAAQrB,GAAW,IAChCC,EAAaoB,EAAbpB,IAAKE,EAAQkB,EAARlB,IACb,OAAIF,EAAM,GAAKE,EAAM,IACjBF,GAAOD,EAAMO,QAAUJ,GAAOH,EAAM,GAAGO,SAIvCiB,EAAsB,SAACC,GAC3B,OAAQA,GACN,IAAK,UACH,OAAOjC,EAAUC,GACnB,IAAK,aACH,OAAOD,EAAUE,MACnB,IAAK,YACH,OAAOF,EAAUI,KACnB,IAAK,YACH,OAAOJ,EAAUG,KACnB,QACE,MAAO,KAIP+B,EAAuB,SAAC3C,EAAM4C,GAClC,GAAkB,OAAd5C,EAAKF,KAAe,OAAO8C,EADwB,MAEV5C,EAAKJ,MAArCuB,EAF0C,EAE/CD,IAAsB2B,EAFyB,EAE9BzB,IAF8B,EAGhBpB,EAAKF,KAAKF,MAApCkD,EAH0C,EAG/C5B,IAAmB6B,EAH4B,EAGjC3B,IACtB,OAAI0B,IAAY3B,GAAc4B,IAAYF,EAAa,EAC9CpC,EAAUE,MAEfmC,IAAY3B,GAAc4B,IAAYF,EAAa,EAC9CpC,EAAUI,KAEfkC,IAAYF,GAAcC,IAAY3B,EAAa,EAC9CV,EAAUG,KAEfmC,IAAYF,GAAcC,IAAY3B,EAAa,EAC9CV,EAAUC,GAEZ,IAGHsC,EAAsB,SAACC,EAAWL,GACtC,IAAMM,EAAwBP,EAC5BM,EACAL,GAEIO,EAAkBC,EAAqBF,GACvCG,EAAoB,CACxBnC,IAAK+B,EAAUrD,MAAMsB,IACrBE,IAAK6B,EAAUrD,MAAMwB,KAMvB,OAJyBiB,EACvBgB,EACAF,IAKEC,EAAuB,SAACb,GAC5B,OAAIA,IAAc9B,EAAUC,GAAWD,EAAUG,KAC7C2B,IAAc9B,EAAUE,MAAcF,EAAUI,KAChD0B,IAAc9B,EAAUG,KAAaH,EAAUC,GAC/C6B,IAAc9B,EAAUI,KAAaJ,EAAUE,WAAnD,GAGI2C,EAAmB,SACvBC,EACAC,EACAC,EACAxB,GAEA,IAAIyB,EAAY,OAUhB,OATIH,IAAcC,IAEdE,EADED,EACU,mBAEA,iBAGZxB,EAAWG,IAAImB,KAAYG,EAAY,mBAEpCA,GAGMC,EA5UD,WAAO,IAAD,EACQC,mBAAS,GADjB,mBACXC,EADW,KACJC,EADI,OAEFF,mBAAS9C,EAXR,KAWVG,EAFW,sBAGQ2C,mBACxB,IAAI7D,EAAiBuB,EAAwBL,KAJ7B,mBAGX8C,EAHW,KAGJC,EAHI,OAMkBJ,mBAClC,IAAIK,IAAI,CAACF,EAAM9D,KAAKL,MAAMgC,QAPV,mBAMXK,EANW,KAMCiC,EAND,OAWcN,mBAAS5B,EAAYC,EAAY,IAX/C,mBAWXuB,EAXW,KAWDW,EAXC,OAYgBP,mBAAS/B,KAZzB,mBAYXU,EAZW,KAYA6B,EAZA,OAakDR,oBAClE,GAdgB,mBAaXH,EAbW,KAaiBY,EAbjB,KAiBlBC,qBAAU,WAKR,OAJAC,OAAOC,iBAAiB,WAAW,SAACC,GAClCC,EAAcD,MAGT,kBACLF,OAAOI,oBAAoB,WAAW,SAACF,GACrCC,EAAcD,UAIpBH,qBAAU,WACR,IAAMM,EAAaC,YAAW,WAC5BC,MACC,KAEH,OAAO,kBAAMC,aAAaH,OAG5B,IAAMF,EAAgB,SAACD,GACrB,IAAMO,EAAevC,EAAoBgC,EAAE/B,KACD,KAAjBsC,IAGvB5B,EAAqB4B,KAAkBzC,GAAaN,EAAWgD,KAAO,GAMxEb,EAAaY,KAGTF,EAAY,WAChB,IAAMI,EAAoB,CACxBhE,IAAK6C,EAAM9D,KAAKL,MAAMsB,IACtBE,IAAK2C,EAAM9D,KAAKL,MAAMwB,KAGlB+D,EAAiB9C,EAAqB6C,EAAmB3C,GAG/D,GAAIC,EAAc2C,EAAgBlE,GAChC,OAAOmE,IAGT,IAAMC,EAAepE,EAAMkE,EAAejE,KAAKiE,EAAe/D,KAC9D,GAAIa,EAAWG,IAAIiD,GACjB,OAAOD,IAGT,IAAME,EAAU,IAAI3F,EAAe,CACjCuB,IAAKiE,EAAejE,IACpBE,IAAK+D,EAAe/D,IACpBQ,KAAMyD,IAGFE,EAAcxB,EAAM9D,KAC1B8D,EAAM9D,KAAOqF,EACbC,EAAYzF,KAAOwF,EAEnB,IAAME,EAAgB,IAAIvB,IAAIhC,GAC9BuD,EAAcC,OAAO1B,EAAM7D,KAAKN,MAAMgC,MACtC4D,EAAcE,IAAIL,GAElBtB,EAAM7D,KAAO6D,EAAM7D,KAAKJ,KACL,OAAfiE,EAAM7D,OAAe6D,EAAM7D,KAAO6D,EAAM9D,MAEvBoF,IAAiB7B,IAGpCmC,EAAUH,GACN/B,GAA4BmC,IAChCC,EAAsBL,EAAehC,IAGvCU,EAAcsB,IAGVG,EAAY,SAACH,GACjB,IAAMM,EAAmB9C,EAAoBe,EAAM7D,KAAMqC,GACzD,IAAIC,EAAcsD,EAAkB7E,GAApC,CAKA,IAAM8E,EAAc9E,EAAM6E,EAAiB5E,KAAK4E,EAAiB1E,KAC3D4E,EAAU,IAAIrG,EAAe,CACjCuB,IAAK4E,EAAiB5E,IACtBE,IAAK0E,EAAiB1E,IACtBQ,KAAMmE,IAEFE,EAAclC,EAAM7D,KAC1B6D,EAAM7D,KAAO8F,EACbjC,EAAM7D,KAAKJ,KAAOmG,EAElBT,EAAcE,IAAIK,KAGdH,EAAe,WACnB,IAAM1C,EAAwBP,EAAqBoB,EAAM7D,KAAMqC,GACzDyC,EAAe5B,EAAqBF,GAC1CkB,EAAaY,GD/HV,SAA2B/E,GAGhC,IAFA,IAAIiG,EAAe,KACfC,EAAclG,EACK,OAAhBkG,GAAsB,CAC3B,IAAMC,EAAWD,EAAYrG,KAC7BqG,EAAYrG,KAAOoG,EACnBA,EAAeC,EACfA,EAAcC,GC4HdC,CAAkBtC,EAAM7D,MACxB,IAAMoG,EAAYvC,EAAM9D,KACxB8D,EAAM9D,KAAO8D,EAAM7D,KACnB6D,EAAM7D,KAAOoG,GAGTT,EAAwB,SAACL,EAAetD,GAC5C,IAAMC,EAAeH,EAAYwD,EAAetD,GAE1CqE,EACJjG,KAAKE,SA7IoC,GA+I3C2D,EAAYhC,GACZkC,EAA8BkC,GAC9BzC,EAASD,EAAQ,IAGbuB,EAAiB,WACrBtB,EAAS,GACT,IAAM0C,EAAuBlF,EAAwBL,GACrD+C,EAAS,IAAIjE,EAAiByG,IAC9BrC,EAAYnC,EAAYC,EAAY,IACpCiC,EAAc,IAAID,IAAI,CAACuC,EAAqB5E,QAC5CwC,EAAavC,MAGf,OACE,qCACE,yCAAYgC,KACZ,qBAAKH,UAAU,QAAf,SACGzC,EAAMwF,KAAI,SAACvF,EAAKwF,GAAN,OACT,qBAAoBhD,UAAU,MAA9B,SACGxC,EAAIuF,KAAI,SAAClD,EAAWoD,GACnB,IAAMjD,EAAYJ,EAChBC,EACAC,EACAC,EACAxB,GAEF,OAAO,qBAAqByB,UAAWA,GAAtBiD,OARXD,YC7JLE,G,MARH,WACV,OACE,qBAAKlD,UAAU,MAAf,SACE,cAAC,EAAD,QCMSmD,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCDdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bb,M","file":"static/js/main.57cc4eef.chunk.js","sourcesContent":["export class LinkedListNode {\r\n  constructor(value) {\r\n    this.value = value;\r\n    this.next = null;\r\n  }\r\n}\r\n\r\nexport class SinglyLinkedList {\r\n  constructor(value) {\r\n    const node = new LinkedListNode(value);\r\n    this.head = node;\r\n    this.tail = node;\r\n  }\r\n}\r\n","// Copied from https://stackoverflow.com/questions/4959975/generate-random-number-between-two-numbers-in-javascript\r\nexport function randomIntFromInterval(min, max) {\r\n  // min and max included\r\n  return Math.floor(Math.random() * (max - min + 1) + min);\r\n}\r\n\r\nexport function reverseLinkedList(head) {\r\n  let previousNode = null;\r\n  let currentNode = head;\r\n  while (currentNode !== null) {\r\n    const nextNode = currentNode.next;\r\n    currentNode.next = previousNode;\r\n    previousNode = currentNode;\r\n    currentNode = nextNode;\r\n  }\r\n\r\n  return previousNode;\r\n}\r\n","import React, { useState, useEffect } from \"react\";\r\nimport { LinkedListNode, SinglyLinkedList } from \"./LinkedList\";\r\nimport { randomIntFromInterval, reverseLinkedList } from \"../lib/utils\";\r\nimport \"./Board.css\";\r\n\r\nconst BOARD_SIZE = 10;\r\nconst PROBABILITY_OF_DIRECTION_REVERSAL_FOOD = 0.3;\r\nconst DIRECTION = {\r\n  UP: \"UP\",\r\n  RIGHT: \"RIGHT\",\r\n  DOWN: \"DOWN\",\r\n  LEFT: \"LEFT\",\r\n};\r\n\r\nconst Board = () => {\r\n  const [score, setScore] = useState(0);\r\n  const [board] = useState(createBoard(BOARD_SIZE));\r\n  const [snake, setSnake] = useState(\r\n    new SinglyLinkedList(getStartingSnakeLLValue(board))\r\n  );\r\n  const [snakeCells, setSnakeCells] = useState(\r\n    new Set([snake.head.value.cell])\r\n  );\r\n\r\n  // Set the food 5 cells away from the starting point of the snake\r\n  const [foodCell, setFoodCell] = useState(getFoodCell(snakeCells, 0));\r\n  const [direction, setDirection] = useState(getRandomDirection());\r\n  const [foodShouldReverseDirection, setFoodShouldReverseDirection] = useState(\r\n    false\r\n  );\r\n\r\n  useEffect(() => {\r\n    window.addEventListener(\"keydown\", (e) => {\r\n      handleKeydown(e);\r\n    });\r\n\r\n    return () =>\r\n      window.removeEventListener(\"keydown\", (e) => {\r\n        handleKeydown(e);\r\n      });\r\n  });\r\n\r\n  useEffect(() => {\r\n    const snakeSpeed = setTimeout(() => {\r\n      moveSnake();\r\n    }, 150);\r\n\r\n    return () => clearTimeout(snakeSpeed);\r\n  });\r\n\r\n  const handleKeydown = (e) => {\r\n    const newDirection = getDirectionFromKey(e.key);\r\n    const isValidDirection = newDirection !== \"\";\r\n    if (!isValidDirection) return;\r\n    const snakeWillRunIntoItself =\r\n      getOppositeDirection(newDirection) === direction && snakeCells.size > 1;\r\n    // Note: this functionality is currently broken, for the same reason that\r\n    // `useInterval` is needed. Specifically, the `direction` and `snakeCells`\r\n    // will currently never reflect their \"latest version\" when `handleKeydown`\r\n    // is called. I leave it as an exercise to the viewer to fix this :P\r\n    if (snakeWillRunIntoItself) return;\r\n    setDirection(newDirection);\r\n  };\r\n\r\n  const moveSnake = () => {\r\n    const currentHeadCoords = {\r\n      row: snake.head.value.row,\r\n      col: snake.head.value.col,\r\n    };\r\n\r\n    const nextHeadCoords = getCoordsInDirection(currentHeadCoords, direction);\r\n\r\n    // Game over conditions\r\n    if (isOutOfBounds(nextHeadCoords, board)) {\r\n      return handleGameOver();\r\n    }\r\n\r\n    const nextHeadCell = board[nextHeadCoords.row][nextHeadCoords.col];\r\n    if (snakeCells.has(nextHeadCell)) {\r\n      return handleGameOver();\r\n    }\r\n\r\n    const newHead = new LinkedListNode({\r\n      row: nextHeadCoords.row,\r\n      col: nextHeadCoords.col,\r\n      cell: nextHeadCell,\r\n    });\r\n\r\n    const currentHead = snake.head;\r\n    snake.head = newHead;\r\n    currentHead.next = newHead;\r\n\r\n    const newSnakeCells = new Set(snakeCells);\r\n    newSnakeCells.delete(snake.tail.value.cell);\r\n    newSnakeCells.add(nextHeadCell);\r\n\r\n    snake.tail = snake.tail.next;\r\n    if (snake.tail === null) snake.tail = snake.head;\r\n\r\n    const foodConsumed = nextHeadCell === foodCell;\r\n    if (foodConsumed) {\r\n      // This function mutates the newSnakeCells\r\n      growSnake(newSnakeCells);\r\n      if (foodShouldReverseDirection) reverseSnake();\r\n      handleFoodConsumption(newSnakeCells, foodCell);\r\n    }\r\n\r\n    setSnakeCells(newSnakeCells);\r\n  };\r\n\r\n  const growSnake = (newSnakeCells) => {\r\n    const growthNodeCoords = getGrowthNodeCoords(snake.tail, direction);\r\n    if (isOutOfBounds(growthNodeCoords, board)) {\r\n      // Snake will grow outside the boundaries of the board; don't do anything\r\n      return;\r\n    }\r\n\r\n    const newTailCell = board[growthNodeCoords.row][growthNodeCoords.col];\r\n    const newTail = new LinkedListNode({\r\n      row: growthNodeCoords.row,\r\n      col: growthNodeCoords.col,\r\n      cell: newTailCell,\r\n    });\r\n    const currentTail = snake.tail;\r\n    snake.tail = newTail;\r\n    snake.tail.next = currentTail;\r\n\r\n    newSnakeCells.add(newTailCell);\r\n  };\r\n\r\n  const reverseSnake = () => {\r\n    const tailNextNodeDirection = getNextNodeDirection(snake.tail, direction);\r\n    const newDirection = getOppositeDirection(tailNextNodeDirection);\r\n    setDirection(newDirection);\r\n\r\n    // The tail of the snake is really the head of the linked list, which\r\n    // is why we have to pass the snake's tail to `reverseLinkedList`.\r\n    reverseLinkedList(snake.tail);\r\n    const snakeHead = snake.head;\r\n    snake.head = snake.tail;\r\n    snake.tail = snakeHead;\r\n  };\r\n\r\n  const handleFoodConsumption = (newSnakeCells, currentFoodCell) => {\r\n    const nextFoodCell = getFoodCell(newSnakeCells, currentFoodCell);\r\n\r\n    const nextFoodShouldReverseDirection =\r\n      Math.random() < PROBABILITY_OF_DIRECTION_REVERSAL_FOOD;\r\n\r\n    setFoodCell(nextFoodCell);\r\n    setFoodShouldReverseDirection(nextFoodShouldReverseDirection);\r\n    setScore(score + 1);\r\n  };\r\n\r\n  const handleGameOver = () => {\r\n    setScore(0);\r\n    const snakeLLStartingValue = getStartingSnakeLLValue(board);\r\n    setSnake(new SinglyLinkedList(snakeLLStartingValue));\r\n    setFoodCell(getFoodCell(snakeCells, 0));\r\n    setSnakeCells(new Set([snakeLLStartingValue.cell]));\r\n    setDirection(getRandomDirection());\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <h2>Score: {score}</h2>\r\n      <div className=\"board\">\r\n        {board.map((row, rowIndex) => (\r\n          <div key={rowIndex} className=\"row\">\r\n            {row.map((cellValue, cellIndex) => {\r\n              const className = getCellClassName(\r\n                cellValue,\r\n                foodCell,\r\n                foodShouldReverseDirection,\r\n                snakeCells\r\n              );\r\n              return <div key={cellIndex} className={className}></div>;\r\n            })}\r\n          </div>\r\n        ))}\r\n      </div>\r\n    </>\r\n  );\r\n};\r\n\r\nconst createBoard = (BOARD_SIZE) => {\r\n  let counter = 1;\r\n  const board = [];\r\n  for (let row = 0; row < BOARD_SIZE; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < BOARD_SIZE; col++) {\r\n      currentRow.push(counter++);\r\n    }\r\n    board.push(currentRow);\r\n  }\r\n  return board;\r\n};\r\n\r\nconst getStartingSnakeLLValue = (board) => {\r\n  const rowSize = board.length;\r\n  const colSize = board[0].length;\r\n  const startingRow = randomIntFromInterval(0, rowSize - 1);\r\n  const startingCol = randomIntFromInterval(1, colSize);\r\n  const startingCell = board[startingRow][startingCol];\r\n  return {\r\n    row: startingRow,\r\n    col: startingCol,\r\n    cell: startingCell,\r\n  };\r\n};\r\n\r\nconst getRandomDirection = () => {\r\n  return Object.keys(DIRECTION)[randomIntFromInterval(0, 4)];\r\n};\r\n\r\n/**\r\n  In practice, this will never be a time-consuming operation. Even\r\n  in the extreme scenario where a snake is so big that it takes up 90%\r\n  of the board (nearly impossible), there would be a 10% chance of generating\r\n  a valid new food cell--so an average of 10 operations: trivial.\r\n*/\r\nconst getFoodCell = (snakeCells, currentFoodCell) => {\r\n  const maxPossibleCellValue = BOARD_SIZE * BOARD_SIZE;\r\n\r\n  while (true) {\r\n    let nextFoodCell = randomIntFromInterval(1, maxPossibleCellValue);\r\n    if (snakeCells.has(nextFoodCell) || currentFoodCell === nextFoodCell)\r\n      continue;\r\n    return nextFoodCell;\r\n  }\r\n};\r\n\r\nconst getCoordsInDirection = (coords, direction) => {\r\n  switch (direction) {\r\n    case DIRECTION.UP:\r\n      return {\r\n        row: coords.row - 1,\r\n        col: coords.col,\r\n      };\r\n    case DIRECTION.RIGHT:\r\n      return {\r\n        row: coords.row,\r\n        col: coords.col + 1,\r\n      };\r\n    case DIRECTION.DOWN:\r\n      return {\r\n        row: coords.row + 1,\r\n        col: coords.col,\r\n      };\r\n    case DIRECTION.LEFT:\r\n      return {\r\n        row: coords.row,\r\n        col: coords.col - 1,\r\n      };\r\n    default:\r\n      return {\r\n        row: coords.row,\r\n        col: coords.col,\r\n      };\r\n  }\r\n};\r\n\r\nconst isOutOfBounds = (coords, board) => {\r\n  const { row, col } = coords;\r\n  if (row < 0 || col < 0) return true;\r\n  if (row >= board.length || col >= board[0].length) return true;\r\n  return false;\r\n};\r\n\r\nconst getDirectionFromKey = (key) => {\r\n  switch (key) {\r\n    case \"ArrowUp\":\r\n      return DIRECTION.UP;\r\n    case \"ArrowRight\":\r\n      return DIRECTION.RIGHT;\r\n    case \"ArrowLeft\":\r\n      return DIRECTION.LEFT;\r\n    case \"ArrowDown\":\r\n      return DIRECTION.DOWN;\r\n    default:\r\n      return \"\";\r\n  }\r\n};\r\n\r\nconst getNextNodeDirection = (node, currentDirection) => {\r\n  if (node.next === null) return currentDirection;\r\n  const { row: currentRow, col: currentCol } = node.value;\r\n  const { row: nextRow, col: nextCol } = node.next.value;\r\n  if (nextRow === currentRow && nextCol === currentCol + 1) {\r\n    return DIRECTION.RIGHT;\r\n  }\r\n  if (nextRow === currentRow && nextCol === currentCol - 1) {\r\n    return DIRECTION.LEFT;\r\n  }\r\n  if (nextCol === currentCol && nextRow === currentRow + 1) {\r\n    return DIRECTION.DOWN;\r\n  }\r\n  if (nextCol === currentCol && nextRow === currentRow - 1) {\r\n    return DIRECTION.UP;\r\n  }\r\n  return \"\";\r\n};\r\n\r\nconst getGrowthNodeCoords = (snakeTail, currentDirection) => {\r\n  const tailNextNodeDirection = getNextNodeDirection(\r\n    snakeTail,\r\n    currentDirection\r\n  );\r\n  const growthDirection = getOppositeDirection(tailNextNodeDirection);\r\n  const currentTailCoords = {\r\n    row: snakeTail.value.row,\r\n    col: snakeTail.value.col,\r\n  };\r\n  const growthNodeCoords = getCoordsInDirection(\r\n    currentTailCoords,\r\n    growthDirection\r\n  );\r\n  return growthNodeCoords;\r\n};\r\n\r\nconst getOppositeDirection = (direction) => {\r\n  if (direction === DIRECTION.UP) return DIRECTION.DOWN;\r\n  if (direction === DIRECTION.RIGHT) return DIRECTION.LEFT;\r\n  if (direction === DIRECTION.DOWN) return DIRECTION.UP;\r\n  if (direction === DIRECTION.LEFT) return DIRECTION.RIGHT;\r\n};\r\n\r\nconst getCellClassName = (\r\n  cellValue,\r\n  foodCell,\r\n  foodShouldReverseDirection,\r\n  snakeCells\r\n) => {\r\n  let className = \"cell\";\r\n  if (cellValue === foodCell) {\r\n    if (foodShouldReverseDirection) {\r\n      className = \"cell cell-purple\";\r\n    } else {\r\n      className = \"cell cell-red\";\r\n    }\r\n  }\r\n  if (snakeCells.has(cellValue)) className = \"cell cell-green\";\r\n\r\n  return className;\r\n};\r\n\r\nexport default Board;\r\n","import Board from \"./components/Board\";\nimport \"./App.css\";\n\nconst App = () => {\n  return (\n    <div className=\"App\">\n      <Board />\n    </div>\n  );\n};\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}